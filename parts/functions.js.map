{"version":3,"sources":["functions.es"],"names":["AKASHI_INTERVAL","DOCKING_OFFSET","MINOR_PERCENT","minuteCeil","time","minute","Math","ceil","akashiEstimate","api_nowhp","api_maxhp","api_ndock_time","max","timePerHPCalc","getTimePerHP","api_lv","api_stype","factor","floor","sqrt","repairEstimate","timePerHP","timeElapsed","availableSRF","min","getHPLabelStyle","nowhp","maxhp","inRepair","percentage","getCountdownLabelStyle","props","timeRemaining"],"mappings":"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","file":"functions.es","sourcesContent":["import FACTOR from './factor'\n\nexport const AKASHI_INTERVAL = 20 * 60 * 1000 // minimum time required, in ms\nconst DOCKING_OFFSET = 30 * 1000 // offset in docking time formula\nconst MINOR_PERCENT = 0.5 // minor damage determination\n\nconst minuteCeil = (time) => {\n  const minute = 60 * 1000\n\n  return Math.ceil(time / minute) * minute\n}\n\n// estimate the time needed in anchorage repair\nexport const akashiEstimate = ({ api_nowhp, api_maxhp, api_ndock_time }) => {\n  if (api_ndock_time === 0 || api_nowhp >= api_maxhp) return 0\n\n  if (api_nowhp <= api_maxhp * MINOR_PERCENT) return 0 // damage check\n\n  if (api_maxhp - api_nowhp === 1) return AKASHI_INTERVAL // if only 1 hp to repair\n\n  return Math.max(minuteCeil(api_ndock_time - DOCKING_OFFSET), AKASHI_INTERVAL)\n}\n\nexport const timePerHPCalc = ({ api_nowhp, api_maxhp, api_ndock_time }) =>\n  (api_nowhp < api_maxhp && api_nowhp >= api_maxhp * MINOR_PERCENT)\n  ? ((api_ndock_time - DOCKING_OFFSET) / (api_maxhp - api_nowhp))\n  : 0\n\n// alternative way for timePerHP\nexport const getTimePerHP = (api_lv = 1, api_stype = 1) => {\n  let factor\n  if (FACTOR[api_stype] != null) factor = FACTOR[api_stype].factor || 0\n\n  if (factor === 0) return 0\n\n  if (api_lv < 12) {\n    return api_lv * 10 * factor * 1000\n  }\n\n  return ((api_lv * 5) + ((Math.floor(Math.sqrt(api_lv - 11)) * 10) + 50)) * factor * 1000\n}\n\nexport const repairEstimate =\n({ api_nowhp, api_maxhp, timePerHP }, timeElapsed = 0, availableSRF = false) => {\n  // timeElapsed is in seconds\n  if (api_nowhp >= api_maxhp || timePerHP === 0 || !availableSRF) return 0\n\n  if (timeElapsed * 1000 < AKASHI_INTERVAL) {\n    return 0\n  }\n\n  return Math.min(Math.max(Math.floor((timeElapsed * 1000) / timePerHP), 1), api_maxhp - api_nowhp)\n}\n\nexport const getHPLabelStyle = (nowhp, maxhp, availableSRF = true, inRepair = false) => {\n  const percentage = nowhp / maxhp\n  if (!availableSRF) {\n    return 'warning'\n  }\n  switch (true) {\n    case (percentage >= 1 || inRepair):\n      return 'success'\n    case (percentage >= MINOR_PERCENT):\n      return 'primary'\n    case (percentage < MINOR_PERCENT):\n      return 'warning'\n    default:\n      return 'warning'\n  }\n}\n\nexport const getCountdownLabelStyle = (props, timeRemaining) => {\n  switch (true) {\n    case (timeRemaining > 600):\n      return 'primary'\n    case (timeRemaining > 60):\n      return 'warning'\n    case (timeRemaining >= 0):\n      return 'success'\n    default:\n      return 'default'\n  }\n}\n"]}
